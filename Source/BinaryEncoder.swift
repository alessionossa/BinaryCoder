
import CoreFoundation


/// A protocol for types which can be encoded to binary.
public protocol BinaryEncodable: Encodable {
    func binaryEncode(to encoder: Encoder) throws
}

/// Provide a default implementation which calls through to `Encodable`. This
/// allows `BinaryEncodable` to use the `Encodable` implementation generated by the
/// compiler.
public extension BinaryEncodable {
    func binaryEncode(to encoder: Encoder) throws {
        try self.encode(to: encoder)
    }
}

/// The actual binary encoder class.
public class BinaryEncoder {
    
    public init() {}
}

/*
/// A convenience function for creating an encoder, encoding a value, and
/// extracting the resulting data.
public extension BinaryEncoder {
    static func encode(_ value: BinaryEncodable) throws -> [UInt8] {
        let encoder = BinaryEncoder()
        try value.binaryEncode(to: encoder)
        return encoder.data
    }
}
 */

/// The error type.
public extension BinaryEncoder {
    /// All errors which `BinaryEncoder` itself can throw.
    enum Error: Swift.Error {
        /// Attempted to encode a type which is `Encodable`, but not `BinaryEncodable`. (We
        /// require `BinaryEncodable` because `BinaryEncoder` doesn't support full keyed
        /// coding functionality.)
        case typeNotConformingToBinaryEncodable(Encodable.Type)
        
        /// Attempted to encode a type which is not `Encodable`.
        case typeNotConformingToEncodable(Any.Type)
        
        /// Attempted to encode a `UInt32` which can't be represented. Because the
        /// lenght can't be represented with `UInt32`
        case lenghtOutOfRange(UInt64)
        
        case containerTypeNotImplemented

    }
    
    func encode(_ encodable: Encodable) throws -> [UInt8] {
        let encoder = _BinaryEncoder()
        let encoded = try encoder.box_(encodable)
        
        return encoded
    }
}

/// Methods for encoding various types.
private class _BinaryEncoder {
    
    var container: [UInt8] = []
    
    func box(_ value: Bool)     -> [UInt8] { return getBytes(of: value ? 1 as UInt8 : 0 as UInt8) }
    
    func box(_ value: Float)    -> [UInt8] { return getBytes(of: value) }
    func box(_ value: Double)   -> [UInt8] { return getBytes(of: value) }
    
    func box(_ value: Int)      -> [UInt8] { return box(Int64(value)) }
    func box(_ value: UInt)     -> [UInt8] { return box(UInt64(value)) }
    
    func box(_ value: Int8)     -> [UInt8] { return getBytes(of: value.littleEndian) }
    func box(_ value: Int16)    -> [UInt8] { return getBytes(of: value.littleEndian) }
    func box(_ value: Int32)    -> [UInt8] { return getBytes(of: value.littleEndian) }
    func box(_ value: Int64)    -> [UInt8] { return getBytes(of: value.littleEndian) }
    func box(_ value: UInt8)    -> [UInt8] { return getBytes(of: value.littleEndian) }
    func box(_ value: UInt16)   -> [UInt8] { return getBytes(of: value.littleEndian) }
    func box(_ value: UInt32)   -> [UInt8] { return getBytes(of: value.littleEndian) }
    func box(_ value: UInt64)   -> [UInt8] { return getBytes(of: value.littleEndian) }
    
    func box(_ value: Encodable) throws -> [UInt8] {
        return try self.box_(value)
    }
    
    func box_(_ value: Encodable) throws -> [UInt8] {
        switch value {
        
        case let binary as BinaryEncodable:
            try binary.binaryEncode(to: self)
            return self.container
            
        default:
            throw BinaryEncoder.Error.typeNotConformingToBinaryEncodable(type(of: value))
        }
    }
    /*
     func encode(_ encodable: Encodable) throws {
        switch encodable {
            
        case let binary as BinaryEncodable:
            try binary.binaryEncode(to: self)
            
        default:
            throw BinaryEncoder.Error.typeNotConformingToBinaryEncodable(type(of: encodable))
        }
    }*/
    
    /// Append the raw bytes of the parameter to the encoder's data. No byte-swapping
    /// or other encoding is done.
    func getBytes<T>(of: T) -> [UInt8] {
        let target = of
        let buffer = withUnsafeBytes(of: target) {
            return $0
        }
        return [UInt8].init(buffer)
    }
}

extension _BinaryEncoder: Encoder {
    public var codingPath: [CodingKey] { return [] }
    
    public var userInfo: [CodingUserInfoKey : Any] { return [:] }
    
    public func container<Key>(keyedBy type: Key.Type) -> KeyedEncodingContainer<Key> where Key : CodingKey {
        return KeyedEncodingContainer(KeyedContainer<Key>(encoder: self))
    }
    
    public func unkeyedContainer() -> UnkeyedEncodingContainer {
        return _BinaryUnkeyedContainer(encoder: self)
    }
    
    public func singleValueContainer() -> SingleValueEncodingContainer {
        return _BinaryUnkeyedContainer(encoder: self)
    }
    
    private struct KeyedContainer<Key: CodingKey>: KeyedEncodingContainerProtocol {
        
        var encoder: _BinaryEncoder
        
        //var container: [UInt8]
        
        var codingPath: [CodingKey] { return [] }
        
        func encodeNil(forKey key: Key) throws {}
        
        public mutating func encode(_ value: Bool, forKey key: Key)      throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        
        public mutating func encode(_ value: Float, forKey key: Key)     throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: Double, forKey key: Key)    throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        
        public mutating func encode(_ value: Int, forKey key: Key)       throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: UInt, forKey key: Key)      throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        
        public mutating func encode(_ value: Int8, forKey key: Key)      throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: Int16, forKey key: Key)     throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: Int32, forKey key: Key)     throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: Int64, forKey key: Key)     throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: UInt8, forKey key: Key)     throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: UInt16, forKey key: Key)    throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: UInt32, forKey key: Key)    throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: UInt64, forKey key: Key)    throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        
        public mutating func encode<T>(_ value: T, forKey key: Key) throws where T : Encodable {
            self.encoder.container.append(contentsOf: try encoder.box(value))
        }
        
        func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type, forKey key: Key) -> KeyedEncodingContainer<NestedKey> where NestedKey : CodingKey {
            return encoder.container(keyedBy: keyType)
        }
        
        func nestedUnkeyedContainer(forKey key: Key) -> UnkeyedEncodingContainer {
            return encoder.unkeyedContainer()
        }
        
        func superEncoder() -> Encoder {
            return encoder
        }
        
        func superEncoder(forKey key: Key) -> Encoder {
            return encoder
        }
    }
    
    private struct _BinaryUnkeyedContainer: UnkeyedEncodingContainer, SingleValueEncodingContainer {
        
        let encoder: _BinaryEncoder
        
        //var container: [UInt8]
        
        var codingPath: [CodingKey] { return [] }
        
        var count: Int { return 0 }

        func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type) -> KeyedEncodingContainer<NestedKey> where NestedKey : CodingKey {
            return encoder.container(keyedBy: keyType)
        }
        
        func nestedUnkeyedContainer() -> UnkeyedEncodingContainer {
            return self
        }
        
        func superEncoder() -> Encoder {
            return encoder
        }
        
        func encodeNil() throws {}
        
        public mutating func encode(_ value: Bool)      throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        
        public mutating func encode(_ value: Float)     throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: Double)    throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        
        public mutating func encode(_ value: Int)       throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: UInt)      throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        
        public mutating func encode(_ value: Int8)      throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: Int16)     throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: Int32)     throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: Int64)     throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: UInt8)     throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: UInt16)    throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: UInt32)    throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        public mutating func encode(_ value: UInt64)    throws  { self.encoder.container.append(contentsOf: self.encoder.box(value)) }
        
        public mutating func encode<T>(_ value: T) throws where T : Encodable {
            self.encoder.container.append(contentsOf: try encoder.box(value))
        }
    }
}
